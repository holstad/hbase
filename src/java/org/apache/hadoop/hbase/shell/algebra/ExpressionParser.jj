options {
  STATIC = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(ExpressionParser)
package org.apache.hadoop.hbase.shell.algebra.generated;

/**
 * Copyright 2007 The Apache Software Foundation
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;

import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.HTable;
import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
import org.apache.hadoop.io.MapWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.io.Writable;

/**
 * Parsing command line.
 */
public class ExpressionParser {
  HBaseConfiguration conf = new HBaseConfiguration();
  private String expression;
  private String joinKeyColumn;
  private String secondRelation;
  private Map<String, List<String>> unionSet = new HashMap<String, List<String>>();
  private Map<String, List<String>> intersectionSet = new HashMap<String, List<String>>();
  private SortedMap<Text, byte[]> secondValue = null;

  public ExpressionParser(final String expression) {
    this((Reader)(new StringReader(expression)));
    this.expression = expression;
  }
  
  public String getExpression() {
    return this.expression;
  }
}

PARSER_END(ExpressionParser)

SKIP :                             
{
    " "
 | "\t"
 | "\r"
 | "\n"
}

TOKEN : /** Literals */
{
   <ROW: "row">
 | <AND: "and">
 | <OR: "or">
 | <DOT: ".">
 | <EQUALS: "=">
 | <LCOMP: ">">
 | <RCOMP: "<">
 | <LCOMPE: ">=">
 | <RCOMPE: "<=">
 | <IN: "==">
 | <NOTIN: "!!">
 | <BAR: "|">
 | <BOOL: "bool">
 | <ID: ["A"-"Z","a"-"z","_","-",":","/"] (["A"-"Z","a"-"z","0"-"9","_","-",":","/"])* >
 | <INTEGER_LITERAL: (["0"-"9"])+ >
 | <FLOATING_POINT_LITERAL:
   (["0"-"9"])+ "." (["0"-"9"])+ (<EXPONENT>)?
  | "." (["0"-"9"])+ (<EXPONENT>)?
  | (["0"-"9"])+ <EXPONENT>
  | (["0"-"9"])+ (<EXPONENT>)?
   >
 | <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
 | <QUOTED_IDENTIFIER: "\"" (~["\""])+ "\"" >
 | <STRING_LITERAL: "'" (~["'"])* ( "''" (~["'"])* )* "'" >
}

void booleanExpressionParse() :
{
  Map<String, List<String>> temp = new HashMap<String, List<String>>();
}
{
  temp = booleanTerm()
  (
    (
        <AND>
        { 
          if(temp != null) {
            for(Map.Entry<String, List<String>> e : temp.entrySet()) {
              List<String> newList = intersectionSet.get(e.getKey());
              if(newList != null) {
                newList.addAll(e.getValue());
              } else {
                newList = e.getValue();
              }
              intersectionSet.put(e.getKey(), newList);
            }
          }
          temp = booleanTerm();
          for(Map.Entry<String, List<String>> e : temp.entrySet()) {
            List<String> newList = intersectionSet.get(e.getKey());
            if(newList != null) {
              newList.addAll(e.getValue());
            } else {
              newList = e.getValue();
            }
            intersectionSet.put(e.getKey(), newList);
          }
          temp = null;
          }
      | <OR>
        {
        if(temp != null) {
          for(Map.Entry<String, List<String>> e : temp.entrySet()) {
            List<String> newList = unionSet.get(e.getKey());
            if(newList != null) {
              newList.addAll(e.getValue());
            } else {
              newList = e.getValue();
            }
            unionSet.put(e.getKey(), newList);
          }    
        }
        temp = booleanTerm();
        for(Map.Entry<String, List<String>> e : temp.entrySet()) {
          List<String> newList = unionSet.get(e.getKey());
          if(newList != null) {
            newList.addAll(e.getValue());
          } else {
            newList = e.getValue();
          }
          unionSet.put(e.getKey(), newList);
        }
        temp = null;
        }
      ) 
  )* 
  {
    if(temp != null) {
      for(Map.Entry<String, List<String>> e : temp.entrySet()) {
        List<String> newList = unionSet.get(e.getKey());
        if(newList != null) {
          newList.addAll(e.getValue());
        } else {
          newList = e.getValue();
        }
        unionSet.put(e.getKey(), newList);
      }
    }
  }
}

void joinExpressionParse() :
{
  Map<String, List<String>> temp = new HashMap<String, List<String>>();
}
{
  indexJoinCondition()
  <BOOL>
  [
    temp = booleanTerm()
      (
      (
       <AND>
       { 
         if(temp != null) {
           for(Map.Entry<String, List<String>> e : temp.entrySet()) {
             List<String> newList = intersectionSet.get(e.getKey());
             if(newList != null) {
               newList.addAll(e.getValue());
             } else {
               newList = e.getValue();
             }
             intersectionSet.put(e.getKey(), newList);
           }
         }
         temp = booleanTerm();
         for(Map.Entry<String, List<String>> e : temp.entrySet()) {
           List<String> newList = intersectionSet.get(e.getKey());
           if(newList != null) {
             newList.addAll(e.getValue());
           } else {
             newList = e.getValue();
           }
           intersectionSet.put(e.getKey(), newList);
         }
         temp = null;
         }
      | <OR>
        {
        if(temp != null) {
          for(Map.Entry<String, List<String>> e : temp.entrySet()) {
            List<String> newList = unionSet.get(e.getKey());
            if(newList != null) {
              newList.addAll(e.getValue());
            } else {
              newList = e.getValue();
            }
            unionSet.put(e.getKey(), newList);
          }
        }
        temp = booleanTerm();
        for(Map.Entry<String, List<String>> e : temp.entrySet()) {
          List<String> newList = unionSet.get(e.getKey());
          if(newList != null) {
            newList.addAll(e.getValue());
          } else {
            newList = e.getValue();
          }
          unionSet.put(e.getKey(), newList);
        }
        temp = null;
        }
      ) 
    )* 
    {
      if(temp != null) {
        for(Map.Entry<String, List<String>> e : temp.entrySet()) {
          List<String> newList = unionSet.get(e.getKey());
          if(newList != null) {
            newList.addAll(e.getValue());
          } else {
            newList = e.getValue();
          }
          unionSet.put(e.getKey(), newList);
        }
        }
    }
  ]
}

void indexJoinCondition() :
{
 Token firstR = null; 
  Token joinKey = null;
  Token secondR = null;
}
{
  firstR=<ID><DOT>joinKey=<ID>
  <EQUALS>
  secondR=<ID><DOT><ROW>
  {
    joinKeyColumn = joinKey.image.toString();
    secondRelation = secondR.image.toString();
  }
}

Map<String, List<String>> booleanTerm() :
{
  Token tSearchName = null;
  Token tComparator = null;
  Token tFirst = null;
  Token tSecond = null;
  Map<String, List<String>> result = new HashMap<String, List<String>>();
  List<String> valueList = new ArrayList<String>();
  String comparand = null;
}
{
  (
      tSearchName=<ID>
    | tSearchName=<INTEGER_LITERAL>
  ) [<DOT> ( tFirst=<ID> | tFirst=<INTEGER_LITERAL> ) ]
  ( tComparator=<EQUALS> | tComparator=<LCOMP> | tComparator=<LCOMPE> | tComparator=<RCOMPE>
  | tComparator=<RCOMP> | tComparator=<IN> | tComparator=<NOTIN> )
  comparand = getValueList()
  [<DOT>  ( tSecond=<ID> | tSecond=<INTEGER_LITERAL> )]

  {
    if(tFirst == null && tSecond == null) {
      valueList.add(tComparator.image.toString() + " " +comparand);
      result.put(tSearchName.image.toString(), valueList);
    } else if (tFirst != null && tSecond != null ){
      if(tSearchName.image.toString().equals(secondRelation)) {
        valueList.add(tComparator.image.toString() + " " 
            + secondValue.get(new Text(tSearchName.image.toString())));
        result.put(tFirst.image.toString(), valueList);
      } else {
        valueList.add(tComparator.image.toString() + " " + tSecond.image.toString());
        result.put(tFirst.image.toString(), valueList);
      }
    }
    return result;
  }
}

String getValueList() :
{
  Token tComparand = null;
  Token tList = null;
  String result = "";
}
{
  ( tComparand=<ID> | tComparand=<INTEGER_LITERAL> )
  {
    result = tComparand.image.toString();
  }
  [
    <BAR>
    (
      (tList=<ID> | tList=<INTEGER_LITERAL> )
      {
        result += "|" + tList.image.toString();
      }
      [ <BAR> ]
    )*
  ]
  { return result; }
}

boolean checkConstraints(MapWritable data) :
{
  Map<String, String> record = getComparisonObject(data);
  boolean result = false;
  if(intersectionSet.size() == 0 && unionSet.size() == 0) {
    return true;
  }
  if (data == null || record.size() == 0) {
    return result; // return false if data is null.
  } 
}
{
  {
      if (intersectionSet.size() == record.size()) {
        result = booleanCompare(intersectionSet, record, true);
      } else if (unionSet.size() == record.size()) {
        result = booleanCompare(unionSet, record, false);
      } else {
        result = getCompareResult(record);
      }
    return result;
  }
}

Map<String, String> getComparisonObject(MapWritable data) :
{
  Map<String, String> result = new HashMap<String, String>();
}
{
  {
    for (Map.Entry<Writable, Writable> e : data.entrySet()) {
      String cKey = e.getKey().toString();
      String val = new String(((ImmutableBytesWritable) e.getValue()).get());

      if (intersectionSet.containsKey(cKey) || unionSet.containsKey(cKey)) {
        result.put(cKey, val);
      }
    }

    return result;
  }
}

MapWritable getJoinColumns(MapWritable value, int numCols, String secondRelation) :
{
  MapWritable appendValue = new MapWritable();
  String joinKey = null;
  this.secondRelation = secondRelation;
}
{
  {
    if (numCols > 0) {
      for (Map.Entry<Writable, Writable> e : value.entrySet()) {
        Text column = (Text) e.getKey();
        for (int i = 0; i < numCols; i++) {
          if (column.equals(new Text(joinKeyColumn))) {
            joinKey = new String(((ImmutableBytesWritable) e.getValue()).get());
            break;
          }
        }
      }
    }
    
    //If joinKey is null, just return.
    if(joinKey == null) {
      return appendValue;
    }
    
    try {
      HTable table = new HTable(conf, new Text(secondRelation));
      secondValue = table.getRow(new Text(joinKey));
      for (Map.Entry<Text, byte[]> e : secondValue.entrySet()) {
        appendValue.put(e.getKey(), new ImmutableBytesWritable(e.getValue()));
      }
    } catch (IOException e) {
      e.printStackTrace();
    }

    return appendValue;
  }
}

boolean getCompareResult(Map<String, String> record) :
{
}
{
  {
      return (booleanCompare(intersectionSet, record, true) && 
          booleanCompare(unionSet, record, false)) ? true : false;
  }
}

boolean booleanCompare(Map<String, List<String>> expression,
    Map<String, String> record, boolean isIntersection) :
{
  boolean negative = true;
  boolean positive = false;
}
{
  {
    try{
      for (Map.Entry<String, List<String>> e : expression.entrySet()) {
        String key = e.getKey();
        List<String> valueList = e.getValue();
        String recordValueList = record.get(key);

        for (int i = 0; i < valueList.size(); i++) {
          String[] term = valueList.get(i).split(" ");
          String comparator = term[0];
          String comparand = term[1];

          switch (comparator.charAt(0)) {
            case '>':
              if (isSecond(comparator, "=")) {
                if (Integer.parseInt(comparand) > Integer
                    .parseInt(recordValueList)) {
                  negative = false;
                } else {
                  positive = true;
                }
              } else {
                if (Integer.parseInt(comparand) > Integer
                    .parseInt(recordValueList)
                    || comparand.equals(recordValueList)) {
                  negative = false;
                } else {
                  positive = true;
                }
              }
              break;
            case '<':
              if (isSecond(comparator, "=")) {
                if (Integer.parseInt(comparand) < Integer
                    .parseInt(recordValueList))
                  negative = false;
                else
                  positive = true;
              } else {
                if (Integer.parseInt(comparand) < Integer
                    .parseInt(recordValueList)
                    || comparand.equals(recordValueList))
                  negative = false;
                else
                  positive = true;
              }
              break;

            case '!':
              if (isSecond(comparator, "!")) {
                boolean checkBool = true;
                String[] coms = comparand.split("[|]");
                for (int j = 0; j < coms.length; j++) {
                  if (URLDecoder.decode(coms[j], "UTF-8").equals(recordValueList)) {
                    checkBool = false;
                  }
                }

                if (!checkBool) {
                  negative = false;
                } else {
                  positive = true;
                }

              } else {
                if (comparand.equals(recordValueList))
                  negative = false;
                else
                  positive = true;
              }
              break;
            case '=':
              if (isSecond(comparator, "=")) {

                boolean checkBool = true;
                String[] coms = comparand.split("[|]");
                for (int j = 0; j < coms.length; j++) {
                  if (URLDecoder.decode(coms[j], "UTF-8").equals(recordValueList)) {
                    checkBool = false;
                  }
                }

                if (checkBool) {
                  negative = false;
                } else {
                  positive = true;
                }

              } else {
                if (!comparand.equals(recordValueList))
                  negative = false;
                else
                  positive = true;
              }
              break;
          }
        }
      }
    } catch (UnsupportedEncodingException e) {
      e.printStackTrace();
    }

    boolean result = false;
    if (isIntersection) {
      result = negative;
    } else {
      result = positive;
    }

    return result;
  }
}

boolean isSecond(String comparator, String string) :
{
}
{
  {
    return (comparator.length() == 2 && string.charAt(0) == comparator.charAt(1)) 
    ? true : false;
  }
}
