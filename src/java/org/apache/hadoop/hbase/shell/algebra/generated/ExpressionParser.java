/* Generated By:JavaCC: Do not edit this line. ExpressionParser.java */
package org.apache.hadoop.hbase.shell.algebra.generated;

/**
 * Copyright 2007 The Apache Software Foundation
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;

import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.HTable;
import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
import org.apache.hadoop.io.MapWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.io.Writable;

/**
 * Parsing command line.
 */
public class ExpressionParser implements ExpressionParserConstants {
  HBaseConfiguration conf = new HBaseConfiguration();
  private String expression;
  private String joinKeyColumn;
  private String secondRelation;
  private Map<String, List<String>> unionSet = new HashMap<String, List<String>>();
  private Map<String, List<String>> intersectionSet = new HashMap<String, List<String>>();
  private SortedMap<Text, byte[]> secondValue = null;

  public ExpressionParser(final String expression) {
    this((Reader)(new StringReader(expression)));
    this.expression = expression;
  }

  public String getExpression() {
    return this.expression;
  }

  final public void booleanExpressionParse() throws ParseException {
  Map<String, List<String>> temp = new HashMap<String, List<String>>();
    temp = booleanTerm();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
      case OR:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
          if(temp != null) {
            for(Map.Entry<String, List<String>> e : temp.entrySet()) {
              List<String> newList = intersectionSet.get(e.getKey());
              if(newList != null) {
                newList.addAll(e.getValue());
              } else {
                newList = e.getValue();
              }
              intersectionSet.put(e.getKey(), newList);
            }
          }
          temp = booleanTerm();
          for(Map.Entry<String, List<String>> e : temp.entrySet()) {
            List<String> newList = intersectionSet.get(e.getKey());
            if(newList != null) {
              newList.addAll(e.getValue());
            } else {
              newList = e.getValue();
            }
            intersectionSet.put(e.getKey(), newList);
          }
          temp = null;
        break;
      case OR:
        jj_consume_token(OR);
        if(temp != null) {
          for(Map.Entry<String, List<String>> e : temp.entrySet()) {
            List<String> newList = unionSet.get(e.getKey());
            if(newList != null) {
              newList.addAll(e.getValue());
            } else {
              newList = e.getValue();
            }
            unionSet.put(e.getKey(), newList);
          }
        }
        temp = booleanTerm();
        for(Map.Entry<String, List<String>> e : temp.entrySet()) {
          List<String> newList = unionSet.get(e.getKey());
          if(newList != null) {
            newList.addAll(e.getValue());
          } else {
            newList = e.getValue();
          }
          unionSet.put(e.getKey(), newList);
        }
        temp = null;
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    if(temp != null) {
      for(Map.Entry<String, List<String>> e : temp.entrySet()) {
        List<String> newList = unionSet.get(e.getKey());
        if(newList != null) {
          newList.addAll(e.getValue());
        } else {
          newList = e.getValue();
        }
        unionSet.put(e.getKey(), newList);
      }
    }
  }

  final public void joinExpressionParse() throws ParseException {
  Map<String, List<String>> temp = new HashMap<String, List<String>>();
    indexJoinCondition();
    jj_consume_token(BOOL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
    case INTEGER_LITERAL:
      temp = booleanTerm();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
        case OR:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          jj_consume_token(AND);
         if(temp != null) {
           for(Map.Entry<String, List<String>> e : temp.entrySet()) {
             List<String> newList = intersectionSet.get(e.getKey());
             if(newList != null) {
               newList.addAll(e.getValue());
             } else {
               newList = e.getValue();
             }
             intersectionSet.put(e.getKey(), newList);
           }
         }
         temp = booleanTerm();
         for(Map.Entry<String, List<String>> e : temp.entrySet()) {
           List<String> newList = intersectionSet.get(e.getKey());
           if(newList != null) {
             newList.addAll(e.getValue());
           } else {
             newList = e.getValue();
           }
           intersectionSet.put(e.getKey(), newList);
         }
         temp = null;
          break;
        case OR:
          jj_consume_token(OR);
        if(temp != null) {
          for(Map.Entry<String, List<String>> e : temp.entrySet()) {
            List<String> newList = unionSet.get(e.getKey());
            if(newList != null) {
              newList.addAll(e.getValue());
            } else {
              newList = e.getValue();
            }
            unionSet.put(e.getKey(), newList);
          }
        }
        temp = booleanTerm();
        for(Map.Entry<String, List<String>> e : temp.entrySet()) {
          List<String> newList = unionSet.get(e.getKey());
          if(newList != null) {
            newList.addAll(e.getValue());
          } else {
            newList = e.getValue();
          }
          unionSet.put(e.getKey(), newList);
        }
        temp = null;
          break;
        default:
          jj_la1[3] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      if(temp != null) {
        for(Map.Entry<String, List<String>> e : temp.entrySet()) {
          List<String> newList = unionSet.get(e.getKey());
          if(newList != null) {
            newList.addAll(e.getValue());
          } else {
            newList = e.getValue();
          }
          unionSet.put(e.getKey(), newList);
        }
        }
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
  }

  final public void indexJoinCondition() throws ParseException {
 Token firstR = null;
  Token joinKey = null;
  Token secondR = null;
    firstR = jj_consume_token(ID);
    jj_consume_token(DOT);
    joinKey = jj_consume_token(ID);
    jj_consume_token(EQUALS);
    secondR = jj_consume_token(ID);
    jj_consume_token(DOT);
    jj_consume_token(ROW);
    joinKeyColumn = joinKey.image.toString();
    secondRelation = secondR.image.toString();
  }

  final public Map<String, List<String>> booleanTerm() throws ParseException {
  Token tSearchName = null;
  Token tComparator = null;
  Token tFirst = null;
  Token tSecond = null;
  Map<String, List<String>> result = new HashMap<String, List<String>>();
  List<String> valueList = new ArrayList<String>();
  String comparand = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      tSearchName = jj_consume_token(ID);
      break;
    case INTEGER_LITERAL:
      tSearchName = jj_consume_token(INTEGER_LITERAL);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        tFirst = jj_consume_token(ID);
        break;
      case INTEGER_LITERAL:
        tFirst = jj_consume_token(INTEGER_LITERAL);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      tComparator = jj_consume_token(EQUALS);
      break;
    case LCOMP:
      tComparator = jj_consume_token(LCOMP);
      break;
    case LCOMPE:
      tComparator = jj_consume_token(LCOMPE);
      break;
    case RCOMPE:
      tComparator = jj_consume_token(RCOMPE);
      break;
    case RCOMP:
      tComparator = jj_consume_token(RCOMP);
      break;
    case IN:
      tComparator = jj_consume_token(IN);
      break;
    case NOTIN:
      tComparator = jj_consume_token(NOTIN);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    comparand = getValueList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        tSecond = jj_consume_token(ID);
        break;
      case INTEGER_LITERAL:
        tSecond = jj_consume_token(INTEGER_LITERAL);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    if(tFirst == null && tSecond == null) {
      valueList.add(tComparator.image.toString() + " " +comparand);
      result.put(tSearchName.image.toString(), valueList);
    } else if (tFirst != null && tSecond != null ){
      if(tSearchName.image.toString().equals(secondRelation)) {
        valueList.add(tComparator.image.toString() + " "
            + secondValue.get(new Text(tSearchName.image.toString())));
        result.put(tFirst.image.toString(), valueList);
      } else {
        valueList.add(tComparator.image.toString() + " " + tSecond.image.toString());
        result.put(tFirst.image.toString(), valueList);
      }
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String getValueList() throws ParseException {
  Token tComparand = null;
  Token tList = null;
  String result = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      tComparand = jj_consume_token(ID);
      break;
    case INTEGER_LITERAL:
      tComparand = jj_consume_token(INTEGER_LITERAL);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    result = tComparand.image.toString();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BAR:
      jj_consume_token(BAR);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
        case INTEGER_LITERAL:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_3;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          tList = jj_consume_token(ID);
          break;
        case INTEGER_LITERAL:
          tList = jj_consume_token(INTEGER_LITERAL);
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        result += "|" + tList.image.toString();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BAR:
          jj_consume_token(BAR);
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
      }
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public boolean checkConstraints(MapWritable data) throws ParseException {
  Map<String, String> record = getComparisonObject(data);
  boolean result = false;
  if(intersectionSet.size() == 0 && unionSet.size() == 0) {
    return true;
  }
  if (data == null || record.size() == 0) {
    return result; // return false if data is null.
  }
      if (intersectionSet.size() == record.size()) {
        result = booleanCompare(intersectionSet, record, true);
      } else if (unionSet.size() == record.size()) {
        result = booleanCompare(unionSet, record, false);
      } else {
        result = getCompareResult(record);
      }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Map<String, String> getComparisonObject(MapWritable data) throws ParseException {
  Map<String, String> result = new HashMap<String, String>();
    for (Map.Entry<Writable, Writable> e : data.entrySet()) {
      String cKey = e.getKey().toString();
      String val = new String(((ImmutableBytesWritable) e.getValue()).get());

      if (intersectionSet.containsKey(cKey) || unionSet.containsKey(cKey)) {
        result.put(cKey, val);
      }
    }

    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public MapWritable getJoinColumns(MapWritable value, int numCols, String secondRelation) throws ParseException {
  MapWritable appendValue = new MapWritable();
  String joinKey = null;
  this.secondRelation = secondRelation;
    if (numCols > 0) {
      for (Map.Entry<Writable, Writable> e : value.entrySet()) {
        Text column = (Text) e.getKey();
        for (int i = 0; i < numCols; i++) {
          if (column.equals(new Text(joinKeyColumn))) {
            joinKey = new String(((ImmutableBytesWritable) e.getValue()).get());
            break;
          }
        }
      }
    }

    //If joinKey is null, just return.
    if(joinKey == null) {
      {if (true) return appendValue;}
    }

    try {
      HTable table = new HTable(conf, new Text(secondRelation));
      secondValue = table.getRow(new Text(joinKey));
      for (Map.Entry<Text, byte[]> e : secondValue.entrySet()) {
        appendValue.put(e.getKey(), new ImmutableBytesWritable(e.getValue()));
      }
    } catch (IOException e) {
      e.printStackTrace();
    }

    {if (true) return appendValue;}
    throw new Error("Missing return statement in function");
  }

  final public boolean getCompareResult(Map<String, String> record) throws ParseException {
      {if (true) return (booleanCompare(intersectionSet, record, true) &&
          booleanCompare(unionSet, record, false)) ? true : false;}
    throw new Error("Missing return statement in function");
  }

  final public boolean booleanCompare(Map<String, List<String>> expression,
    Map<String, String> record, boolean isIntersection) throws ParseException {
  boolean negative = true;
  boolean positive = false;
    try{
      for (Map.Entry<String, List<String>> e : expression.entrySet()) {
        String key = e.getKey();
        List<String> valueList = e.getValue();
        String recordValueList = record.get(key);

        for (int i = 0; i < valueList.size(); i++) {
          String[] term = valueList.get(i).split(" ");
          String comparator = term[0];
          String comparand = term[1];

          switch (comparator.charAt(0)) {
            case '>':
              if (isSecond(comparator, "=")) {
                if (Integer.parseInt(comparand) > Integer
                    .parseInt(recordValueList)) {
                  negative = false;
                } else {
                  positive = true;
                }
              } else {
                if (Integer.parseInt(comparand) > Integer
                    .parseInt(recordValueList)
                    || comparand.equals(recordValueList)) {
                  negative = false;
                } else {
                  positive = true;
                }
              }
              break;
            case '<':
              if (isSecond(comparator, "=")) {
                if (Integer.parseInt(comparand) < Integer
                    .parseInt(recordValueList))
                  negative = false;
                else
                  positive = true;
              } else {
                if (Integer.parseInt(comparand) < Integer
                    .parseInt(recordValueList)
                    || comparand.equals(recordValueList))
                  negative = false;
                else
                  positive = true;
              }
              break;

            case '!':
              if (isSecond(comparator, "!")) {
                boolean checkBool = true;
                String[] coms = comparand.split("[|]");
                for (int j = 0; j < coms.length; j++) {
                  if (URLDecoder.decode(coms[j], "UTF-8").equals(recordValueList)) {
                    checkBool = false;
                  }
                }

                if (!checkBool) {
                  negative = false;
                } else {
                  positive = true;
                }

              } else {
                if (comparand.equals(recordValueList))
                  negative = false;
                else
                  positive = true;
              }
              break;
            case '=':
              if (isSecond(comparator, "=")) {

                boolean checkBool = true;
                String[] coms = comparand.split("[|]");
                for (int j = 0; j < coms.length; j++) {
                  if (URLDecoder.decode(coms[j], "UTF-8").equals(recordValueList)) {
                    checkBool = false;
                  }
                }

                if (checkBool) {
                  negative = false;
                } else {
                  positive = true;
                }

              } else {
                if (!comparand.equals(recordValueList))
                  negative = false;
                else
                  positive = true;
              }
              break;
          }
        }
      }
    } catch (UnsupportedEncodingException e) {
      e.printStackTrace();
    }

    boolean result = false;
    if (isIntersection) {
      result = negative;
    } else {
      result = positive;
    }

    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public boolean isSecond(String comparator, String string) throws ParseException {
    {if (true) return (comparator.length() == 2 && string.charAt(0) == comparator.charAt(1))
    ? true : false;}
    throw new Error("Missing return statement in function");
  }

  public ExpressionParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[16];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xc0,0xc0,0xc0,0xc0,0xc0000,0xc0000,0xc0000,0x100,0xfe00,0xc0000,0x100,0xc0000,0xc0000,0xc0000,0x10000,0x10000,};
   }

  public ExpressionParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public ExpressionParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ExpressionParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public ExpressionParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ExpressionParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public ExpressionParser(ExpressionParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public void ReInit(ExpressionParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[24];
    for (int i = 0; i < 24; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 16; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 24; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
